{
  "name": "EcdsaAccount",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 5,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "signing_pub_key_x",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signing_pub_key_y",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "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ex3MXgez18HsdTB7HcxeB7PXwex1MHsdzF4Hs9fB7HUwe53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXyex1MnudzF4ns9fJ7HUye53MXiez18nsdTJ7ncxeJ7PXaex1zf2VrV9+uOPPTK8kZnolMdMriZleScz0SlJm7DVmeiUx0yuJmV5JzNhKjL3GjK3E2GvM2EqMvabM2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM2EqMvcaMrcTYa8zYSoy9xoytxNhrzNhKjL3GjK3E2GvM2EqMvcaMrcTYa8zQSpax15ihlSxjrzFDK1nGXmOGVrKMvcYMrWQZe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVsJs9fF7HUxe13MXhez18XsdTF7XcxeF7PXxex1MXtdzF4Xs9fF7HUxe13MXhez18XsdTF7XcxeF7PXxex1MXtdzF4Xs9fF7HUxe13MXhez18XsdTF7XcxeF7PXxex1MXtdzF4Xs9fF7HUxe13MXhez18XsdTF7XcxeF7PXxex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7HUze93MXjez183sdTN73cxeN7PXzex1M3vdzF43s9fN7PUwez3MXg+z18Ps9TB7PcxeD7PXw+z1MHs9zF4Ps9fD7PUwez3MXg+z18Ps9TB7PcxeD7PXw+z1MHs9zF4Ps9fD7PUwez3GXnf7/r7p+9dpkemVxEyvJGZ6JTHTK0mZsdeY6ZXETK8kZnolMdMriRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVuJsdeYsZUYe40ZW4mx15ixlRh7jRlbibHXmLGVGHuNGVpJ+xh8zR3ayduhobwdWsrboam8HdrK26GxvB1ay9uhubwd3Ith2NzBvRiIzR3ci6HY3MG9GIzNHdyL4djcwb0YkM0d3Ish2dzBvRiUzR3cC2PZt4N7YTD7dnAvjGbfDu6F4ezbwb0wnn07uBcGtG8H98KI9u3gXhjSvh3cC2Pat4N7YVD7dnAvjGrfDu6FYe3bwb0wrn07uBcGtm8H98LI9u3gXhjavh3cC2Pbt4N7YXD7dnAvjG7fDu6F4e3bwb0wvn07uBcGuG8H98II9+3gXhjivh3cC2Pct4N7YZD7dnAvjHLfDu6FYe7bwb0wzn07uBcGum8H98JI9+3gXhjqvh3cC2Pdt4N7YbD7dnAvjHbfDu6F4e7bwb0w3n07tpcGfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Qdxv03QZ9t0HfbdB3G/TdBn23Qd9t0Hcb9N0GfbdB323Gd8+nf3VnHtXpvaTuMb6bO72X3Om95E7vJXd6L7nTe8md3kvu9F5yx/byGN+NnfHd3MG9GN/NHdyL8d3cwb0Y380d3Ivx3dzBvRjfzR3ci/Hd3MG9GN/NHdyL8d3cwb0Y380d3Ivx3dzBvRjfzR3ci/Hd3MG9GN/NHdyL8d3cwb0Y380d3Ivx3dzBvRjfzR3ci/Hd3MG9GN/NHdyL8d3cwb0Y380d3Ivx3dzBvRjfzR3ci/Hd3MG9GN/NHdyL8d3cwb0Y380d3Ivx3dzBvRjfzR3ci/Hd3MG9GN/NHdyL8d3cwb0Y380d3Ivx3dzBvRjfzR3ci/Hd3MG9GN/NHdyL8d3cwb0Y380d3Ivx3dzBvRjfzR3ci/Hd3MG9GN/NHdwL9N0H+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6Dvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+27Xv1uezfuvqMx/Vyb1cdHIvF53cy0Un93LRyb1cdHIvudO+e9HJvVx0ci8XHdyL9t2LDu5F++5FB/eiffeiY3sZ2ncvOraXoX33omN7Gdp3Lzq2l6F996Jjexnady86uBftuxcd3Iv23YsO7kX77kUH96J996KDe9G+e9HBvWjfvejgXrTvXnRwL9p3Lzq4F+27Fx3ci/bdiw7uRfvuRQf3on33ooN70b570cG9aN+96OBetO9edHAv2ncvOrgX7bsXHdyL9t2LDu5F++5FB/eiffeig3vRvnvRwb1o373o4F607150cC/ady86uBftuxcd3Iv23YsO7kX77kUH96J996KDe9G+e9HBvWjfvejgXrTvXnRwL9p3Lzq4F+27Fx3ci/bdiw7uRfvuRQf3on33ooN70b570cG9QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3l/HdNr7un6j3va06vZfc6b3kTu8ldsZ3c6f3kju9l9zpveRO7yV3ei+5g3sxvps7uBfju6nbxndzx/ayje/mju1lG9/NHdvLNr6bO7aXbXw3d3AvxndzB/difDd3cC/Gd3MH92J8N3dwL8Z3cwf3Ynw3d3AvxndzB/difDd3cC/Gd3MH92J8N3dwL8Z3cwf3Ynw3d3AvxndzB/difDd3cC/Gd3MH92J8N3dwL8Z3cwf3Ynw3d3AvxndzB/difDd3cC/Gd3MH92J8N3dwL8Z3cwf3Ynw3d3AvxndzB/difDd3cC/Gd3MH92J8N3dwL8Z3cwf3Ynw3d3AvxndzB/difDd3cC/Gd3MH92J8N3dwL8Z3cwf3Ynw3d3AvxndzB/difDd3cC/Qdzf03Q19d0Pf3dB3N/TdDX13Q9/d0Hc39N0NfXdD393Qdzf03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/TdA333QN890HcP9N0DffdA3z3Qdw/03QN990DfPdB3D/Pd58N89+3QXt4O7eXt0F7eDu3l7dBe3g7t5e3QXt4O7eXt4F6Y774d3Avz3beDe2G++3ZwL8x33w7uhfnu28G9MN99O7gX5rtvB/fCfPft4F6Y774d3Avz3beDe2G++3ZwL8x33w7uhfnu28G9MN99O7gX5rtvB/fCfPft4F6Y774d3Avz3beDe2G++3ZwL8x33w7uhfnu28G9MN99O7gX5rtvB/fCfPft4F6Y774d3Avz3beDe2G++3ZwL8x33w7uhfnu28G9MN99O7gX5rtvB/fCfPft4F6Y774d3Avz3beDe2G++3ZwL8x33w7uhfnu28G9MN99O7gX5rtvB/fCfPft4F6Y774d3Avz3beDe2G++3ZwL8x33w7uhfnu27G9NOi7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsN+m6Dvtug7zbouw36boO+26DvNui7Dfpug77boO826LsNukaDrtGgazToGg26RoOu0aBrNOgaDbpG067x/vH9W/b+QfBdzc93JZ9CrOQziJV8AqnSThAr+erHSr72sZLvnPeN/1XVURV6NfSn4Nb3VzWWqvSr0ft3tVWlX41U6R2GV0N/+o0VeuX1J99Y6XdKqvQ7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DgVOrSRxhwKnVpK4Q4FTK0ncocCplSTuUODUShJ3KHBqJYk7FDi1ksQdCpxaSeIOBU6tJHGHAqdWkrhDgVMrSdyhwKmVJO5Q4NRKEncocGoliTsUOLWSxB0KnFpJ4g4FTq0kcYcCp1aSuEOBUytJ3KHAqZUk7lDg1EoSdyhwaiWJOxQ4tZKkHSqBUytJ2qESOLWSpB0qgVMrSdqhEji1kqQdKpFTC0ncociphSTuEHbqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkLduqCnbpgpy7YqQt26oKdumCnLtipC3bqgp26YKcu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqSt26oqdumKnrtipK3bqip26Yqeu2KkrduqKnbpip67YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadumGnbtipG3bqhp26Yadu2KkbduqGnbphp27YqRt26oadugVqZ2O7Jm24V0Ju0dV6t8s1mbfsJ4Mrrc6T0dV6L/aS9O9ndLVeIRlcaVVIBldaFZL+M1tJBldaFZLBlVaFZNSh/tIh99qlLVA7Jel3aJ7sgdopSb9DStLvkJL0O6Qk/Q4pSb9DStLvkJKkHeqB2ilJ3KFA7ZQk7lCgdkoSdyhQOyWJOxSonZLEHQrUTkniDgVqpyRxhwK1U5K4Q4GgpZKvyf04xU/6j2dqt1ek1NwrePdA0JSk/3imWl+S/v0MBE1J+o+nkvQfTyXpP55K0t8TlKS/JyjJoEP1dpS6/6efDDokJIMOCcmoQ9NkIGhKMurQPBl1aJ6MOjRPRh2aJ6MOzZO4Q4GgKUncoUDQhGQgaEoSdygQNCWJOxQImpLEHQoETUniDgWCpiRxhwJBU5K4Q4GgKUn38bSLXfXDLmX4SffxlJLu4ykl3cdTSrqPp5L0NUtKuo+nlHQfTynp7glS0t0TpCTukP+tSymJO+R/61JK4g7537qUkrhD/rcupSTukP+tSymJO+R/61JK4g75fislcYd8v5WSuEO+30pJ3CHfb6Uk7pDvt1ISd8j3WylJOzR8v5WStEPD91spSTs0fL+VkrRDw/dbKUk7NHy/lZK4Q77fSkncId9vpSTukO+3UhJ3yPdbKYk75PutlMQd8v1WSuIO+X4rJXGH/G9dSkncId+MpSTukG/GUhJ3yDdjKYk75JuxlMQd8s1YSuIO+WYsJXGHfDOWkrhDvhlLSdwh34ylJO6Qb8ZSEnfI/26W5Vvw1bdqtv4q5886z/mTznN+1+c5v+nznN/zec5v+TQX+NU85zd8nvP7Pc/BvgRuNc/BvgRmNc/BvgReNc/BvgRWNc/BvgRONc/BvgRGNc/BvgQ+Nc/BvgQ2Nc/BvgQuNc/BvgQmNc/BvgQeNc/BvgQWNc/BvgQONc+hvpRLYFDzHOrLnkN92XOoL3sO9aVc6PvTPQmPC/ckPC7ck/C4cE/C9xZ7Er632JPwvcWehO8tyoW+P92T8L3FnsQdou9P9yTuEH1/uidxh+j70z2JO0Tfn5YLfX+6J3GH6PvTPYk7RN+f7kncIf87TVISd8j/TpOUxB3yv9MkJXGH/O80SUncIf87TVISd8j/TpOUxB3yv9MkJXGH/O80SUncIf87TVISdCjV9C/uwuZ8/a51KZdbqJZryF3TWcj/DG2actfyvZT19vF79Xvow/fq99DH79WP1IfvVSnZv1f1cn2EW3o58a7ZNeTeq1nIv1fTlHuv3ku1sn38Xv0e+vC9+j308Xv1I/XBe/WPf/x/MhypBg=="
    ],
    "fileMap": {
      "0": {
        "source": "mod storage;\nmod ecdsa_public_key_note;\n\n// Account contract that uses ECDSA signatures for authentication on the same curve as Ethereum.\n// The signing key is stored in an immutable private note and should be different from the signing key.\ncontract EcdsaAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::log::emit_encrypted_log;\n    use dep::aztec::oracle::get_public_key::get_public_key;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    use dep::aztec::constants_gen::MAX_NOTE_FIELDS_LENGTH;\n    use dep::aztec::note::{\n        note_header::{NoteHeader},\n        utils as note_utils,\n    };\n\n    use crate::storage::Storage;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNote;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNoteInterface;\n    use crate::ecdsa_public_key_note::ECDSA_PUBLIC_KEY_NOTE_LEN;\n\n    // All calls made by this account will be routed through this entrypoint\n    fn entrypoint(  \n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        signature: pub [u8;64],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        \n        // Initialise context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64\n        let mut args: BoundedVec<Field, 77> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in signature { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Load public key from storage\n        let storage = Storage::init();\n        let public_key = storage.public_key.get_note(&mut context);\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n        let hashed_message: [u8; 32] = std::hash::sha256(message_bytes);\n        let verification = std::ecdsa_secp256k1::verify_signature(public_key.x, public_key.y, signature, hashed_message);\n        assert(verification == true);\n\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n        signing_pub_key_x: pub [u8;32],\n        signing_pub_key_y: pub [u8;32],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        let storage = Storage::init();\n        \n        let mut args: BoundedVec<Field, 64> = BoundedVec::new(0);\n        for byte in signing_pub_key_x { args.push(byte as Field); }\n        for byte in signing_pub_key_y { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n        \n        let this = context.this_address();\n        let mut pub_key_note = EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        storage.public_key.initialise(&mut context, &mut pub_key_note);\n        \n        emit_encrypted_log(\n            &mut context,\n            this,\n            storage.public_key.storage_slot,\n            get_public_key(this),\n            pub_key_note.serialise(),\n        );\n\n        context.finish()\n    }\n\n    // Computes note hash and nullifier.\n    // Note 1: Needs to be defined by every contract producing logs.\n    // Note 2: Having it in all the contracts gives us the ability to compute the note hash and nullifier differently for different kind of notes.\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> [Field; 4] {\n        assert(storage_slot == 1);\n        let note_header = NoteHeader { contract_address, nonce, storage_slot };\n        note_utils::compute_note_hash_and_nullifier(EcdsaPublicKeyNoteInterface, note_header, preimage)\n    }\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-contracts/src/contracts/ecdsa_account_contract/src/main"
      },
      "3": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\nfn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\nfn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\nfn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\nfn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\nfn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\nfn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\nfn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "29": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    fn unwrap_or_else(self, default: fn() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    fn map<U>(self, f: fn(T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    fn map_or<U>(self, default: U, f: fn(T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    fn map_or_else<U>(self, default: fn() -> U, f: fn(T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    fn and_then<U>(self, f: fn(T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    fn or_else<U>(self, default: fn() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    fn filter(self, predicate: fn(T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "33": {
        "source": "use crate::context::PrivateContext;\nuse crate::oracle;\nuse crate::types::point::Point;\n\nfn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\nfn emit_unencrypted_log<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let _ = oracle::logs::emit_unencrypted_log(log);\n    context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/log"
      },
      "39": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\nfn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // 0 nonce implies \"transient\" nullifier (must nullify a commitment in this TX).\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.nonce == 0) {\n        // TODO(suyash): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(storage_slot, nullifier, preimage, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/lifecycle"
      },
      "40": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort},\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n    utils::compute_unique_siloed_note_hash,\n    utils::compute_inner_note_hash,\n    utils::compute_siloed_note_hash,\n};\nuse crate::messaging::get_commitment_getter_data::make_commitment_getter_data;\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn ensure_note_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    let saved_note = get_note_internal(storage_slot, note_interface);\n\n    // Only copy over the header to the original note to make sure the preimage is the same.\n    let get_header = note_interface.get_header;\n    let set_header = note_interface.set_header;\n    let note_header = get_header(saved_note);\n    set_header(note, note_header);\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, *note);\n    context.push_read_request(note_hash_for_read_request);\n}\n\n// Ensure a note's hash exists in the tree without retrieving the entire\n// notes via the oracle.\n// Modifies the note by populating it with header info.\nfn ensure_note_hash_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    // Initialize header of note. Must be done before computing note hashes as it initializes the:\n    // - storage slot (used in inner note hash)\n    // - the contract address (used in siloed note hash)\n    // - and the nonce (used in the unique siloed note hash)\n    let set_header = note_interface.set_header;\n    let note_header = NoteHeader {\n        contract_address: (*context).this_address(),\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n        // real nonce (once public kernel applies nonces).\n        nonce: 0,\n        storage_slot\n    };\n    set_header(note, note_header);\n\n    // Get a note from oracle and early out if it doesn't exist.\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let raw_oracle_ret = oracle::get_commitment::get_commitment(inner_note_hash);\n    let deserialized_oracle_ret = make_commitment_getter_data(raw_oracle_ret, 0);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // unique_siloed_note_hash once public kernel applies nonces\n    let saved_siloed_note_hash = deserialized_oracle_ret.message;\n\n    assert(saved_siloed_note_hash != 0); // TODO(dbanks12): necessary?\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    // Ensure that the note hash retrieved from oracle matches the one computed from note.\n    let computed_siloed_note_hash = compute_siloed_note_hash(note_interface, *note);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // compute_note_hash_for_read_or_nullify once public kernel applies nonces\n    assert(computed_siloed_note_hash == saved_siloed_note_hash);\n\n    context.push_read_request(computed_siloed_note_hash);\n}\n\nfn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\nfn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        let mut note_hash_for_read_request = 0;\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            check_note_header(*context, storage_slot, note_interface, note);\n            note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n        };\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n        // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n        context.push_read_request(note_hash_for_read_request);\n    };\n\n    // TODO(#1660)\n    // Move it back to get_notes_internal and only make read request for selected notes.\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_getter"
      },
      "42": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\nfn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\nfn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_hash"
      },
      "46": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nfn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\nfn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\nfn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    if (header.nonce == 0) {\n        // when nonce is zero, that means we are reading a pending note (doesn't have a nonce yet),\n        // so we just read the inner_note_hash (kernel will silo by contract address)\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\nfn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    let mut note = deserialise(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/utils"
      },
      "48": {
        "source": "use dep::std::hash::pedersen_with_separator;\nuse crate::context::PrivateContext;\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle;\nuse crate::constants_gen::{\n    GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n    EMPTY_NULLIFIED_COMMITMENT,\n};\n\nstruct ImmutableSingleton<Note, N> {\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    fn new(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Self {\n        ImmutableSingleton { storage_slot, note_interface }\n    }\n\n    unconstrained fn is_initialised(self) -> bool {\n        let nullifier = self.compute_initialisation_nullifier();\n        oracle::notes::is_nullifier_emitted(nullifier)\n    }\n\n    fn initialise(self, context: &mut PrivateContext, note: &mut Note) {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialisation_nullifier();\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n\n    fn compute_initialisation_nullifier(self) -> Field {\n        pedersen_with_separator([self.storage_slot], GENERATOR_INDEX__INITIALISATION_NULLIFIER)[0]\n    }\n    \n    fn get_note(self, context: &mut PrivateContext) -> Note {\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n\n    unconstrained fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/state_vars/immutable_singleton"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "60": {
        "source": "fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/utils"
      },
      "61": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/private_call_stack_item"
      },
      "62": {
        "source": "use crate::{\n    abi,\n    abi::{\n        PublicCircuitPublicInputs,\n        FunctionData,\n    },\n};\nuse crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__CALL_STACK_ITEM,\n};\n\n// oracles\nuse crate::oracle::{\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n};\n\nstruct PublicCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PublicCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PublicCallStackItem {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}\n\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/public_call_stack_item"
      },
      "65": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/call_private_function"
      },
      "70": {
        "source": "use crate::types::point::Point;\nuse dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\nfn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_public_key"
      },
      "71": {
        "source": "use crate::types::point::Point;\nuse crate::oracle::get_public_key::get_public_key;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(_owner: Point) -> Field {}\n\nunconstrained fn get_secret_key(owner: Field) -> Field {\n    let owner_nullifying_public_key = get_public_key(owner);\n    get_secret_key_oracle(owner_nullifying_public_key)\n}\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_secret_key"
      },
      "73": {
        "source": "\n// contract_address + \n// args_hash +\n// crate::abi::FUNCTION_DATA_SIZE +\n// crate::abi::CALL_CONTEXT_SIZE +\n// = 2 + 4 + 6\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE: Field = 12;\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: Field, \n    _function_selector: Field, \n    _args_hash: Field,\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {}\n\nunconstrained fn enqueue_public_function_call_internal(\n    contract_address: Field, \n    function_selector: Field,\n    args_hash: Field\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE] {\n    enqueue_public_function_call_oracle(\n        contract_address, \n        function_selector, \n        args_hash,\n    )\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/enqueue_public_function_call"
      },
      "75": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _storage_slot: Field,\n    _nullifier: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained fn notify_nullified_note<N>(\n    storage_slot: Field,\n    nullifier: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(storage_slot, nullifier, preimage, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialise the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialise the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_some.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let header = NoteHeader { contract_address, nonce, storage_slot };\n            let is_some = fields[read_offset + 1] as bool;\n            if is_some {\n                let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n                let mut note = deserialise(preimage);\n                set_header(&mut note, header);\n                placeholder_opt_notes[i] = Option::some(note);\n            }\n        };\n    };\n    placeholder_opt_notes\n}\n\nunconstrained fn is_nullifier_emitted(nullifier: Field) -> bool {\n    // TODO\n    nullifier == 0\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/notes"
      },
      "77": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_message: T)  -> Field {}\n\nunconstrained fn emit_unencrypted_log<T>(message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(message), 0]\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/logs"
      },
      "78": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      },
      "81": {
        "source": "use dep::std::hash::pedersen;\nuse dep::aztec::note::note_interface::NoteInterface;\nuse dep::aztec::note::note_header::NoteHeader;\nuse dep::aztec::note::utils::compute_unique_siloed_note_hash;\nuse dep::aztec::oracle::get_secret_key::get_secret_key;\n\nglobal ECDSA_PUBLIC_KEY_NOTE_LEN: Field = 5;\n\n// Stores an ECDSA public key composed of two 32-byte elements\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\nstruct EcdsaPublicKeyNote {\n    x: [u8; 32],\n    y: [u8; 32],\n    owner: Field, // We store the owner address only to get the secret key to compute the nullifier\n    header: NoteHeader,\n}\n\nimpl EcdsaPublicKeyNote {\n    fn new(x: [u8; 32], y: [u8; 32], owner: Field) -> Self {\n        EcdsaPublicKeyNote {\n            x,\n            y,\n            owner,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // Serialise the note as 5 fields where:\n    // [0] = x[0..31] (upper bound excluded)\n    // [1] = x[31]\n    // [2] = y[0..31]\n    // [3] = y[31]\n    // [4] = owner\n    fn serialise(self) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n\n        for i in 1..32 {\n          let bytex: Field = self.x[31 - i] as Field;\n          x = x + (bytex * mul);\n          let bytey: Field = self.y[31 - i] as Field;\n          y = y + (bytey * mul);\n          mul *= 256;\n        }\n\n        let last_x = self.x[31] as Field;\n        let last_y = self.y[31] as Field;\n        \n        let res: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] = [x, last_x, y, last_y, self.owner];\n        res\n    }\n\n    fn compute_nullifier(self) -> Field {\n        let unique_siloed_note_hash = compute_unique_siloed_note_hash(EcdsaPublicKeyNoteInterface, self);\n        let secret = get_secret_key(self.owner);\n        dep::std::hash::pedersen([\n            unique_siloed_note_hash,\n            secret,\n        ])[0]\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialise(preimage: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> EcdsaPublicKeyNote {\n    let mut x: [u8; 32] = [0;32];\n    let mut y: [u8; 32] = [0;32];\n\n    let part_x = preimage[0].to_be_bytes(32);\n    for i in 0..31 { x[i] = part_x[i + 1]; }\n    x[31] = preimage[1].to_be_bytes(32)[31];\n\n    let part_y = preimage[2].to_be_bytes(32);\n    for i in 0..31 { y[i] = part_y[i + 1]; }\n    y[31] = preimage[3].to_be_bytes(32)[31];\n\n    EcdsaPublicKeyNote {\n        x,\n        y,\n        owner: preimage[4],\n        header: NoteHeader::empty(),\n    }\n}\n\nfn serialise(note: EcdsaPublicKeyNote) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n    note.serialise()\n}\n\nfn compute_note_hash(note: EcdsaPublicKeyNote) -> Field {\n    dep::std::hash::pedersen(note.serialise())[0]\n}\n\nfn compute_nullifier(note: EcdsaPublicKeyNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: EcdsaPublicKeyNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut EcdsaPublicKeyNote, header: NoteHeader) {\n    note.set_header(header);\n}\n\nglobal EcdsaPublicKeyNoteInterface = NoteInterface {\n    deserialise,\n    serialise,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n};\n",
        "path": "/Users/adomurad/sources/aztec-packages/yarn-project/noir-contracts/src/contracts/ecdsa_account_contract/src/ecdsa_public_key_note"
      }
    }
  }
}
